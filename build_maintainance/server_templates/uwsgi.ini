[uwsgi]

### GUIDE 1: https://www.techatbloomberg.com/blog/configuring-uwsgi-production-deployment/
### GUIDE 2: https://uwsgi-docs.readthedocs.io/en/latest/ThingsToKnow.html
### VIDGUIDE 3: https://www.youtube.com/watch?v=p6R1h2Nn468

# tells uWSGI to fail to start if any parameter in the configuration file isn’t explicitly understood by uWSGI
strict = true

# Django-related settings
# the base directory (full path)
chdir           = <<DIR_APP_ROOT>>
# Django's wsgi file
module          = <<FILE_UWSGI_APP>>
# the virtualenv (full path)
home            = <<DIR_VENV>>

# process-related settings
# master
master = true
# maximum number of worker processes
processes       = 8
# Without this parameter set, those threads won’t execute and some developer will be stuck in a weird place until they “discover” this feature.
enable-threads = true
# clear environment on exit / Delete sockets during shutdown
vacuum          = true

# we have no plans to ever host more than one service in a given worker process, and I doubt you do either.
single-interpreter = true

# This parameter prevents uWSGI from starting if it is unable to find or load your application module.
need-app = true


# You should enable this feature because it makes uWSGI behave in the way that any sane developer would expect. Without it, kill, or any tool that sends SIGTERM (such as some system monitoring tools) would attempt to kill uWSGI without success
die-on-term = true                   ; Shutdown when receiving SIGTERM (default is respawn)
uid = <<UWSGI_USR>>
gid = <<UWSGI_GRP>>
socket          = <<SOCKET_PATH>>
chmod-socket    = 664

#Uwsgi logs
daemonize = <<_DIR_LOGS>>uwsgi.log # background the process & log
disable-logging = true               ; Disable built-in logging
log-4xx = true                       ; but log 4xx's anyway
log-5xx = true                       ; and 5xx's

harakiri = 360                        ; Forcefully kill workers after 360 seconds

# Worker / Process Labeling
auto-procname = true
procname-prefix = <<PROJECT-ID>>
